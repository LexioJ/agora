<!--
  - SPDX-FileCopyrightText: 2018 Nextcloud contributors
  - SPDX-License-Identifier: AGPL-3.0-or-later
-->
<script setup lang="ts">
import { ref, watch, computed, onMounted, onUnmounted, toRaw } from 'vue'
import { useRouter } from 'vue-router'
import { subscribe, unsubscribe } from '@nextcloud/event-bus'
import { showSuccess, showError } from '@nextcloud/dialogs'
import { useInquiryStore } from '../../stores/inquiry'
import { useInquiriesStore } from '../../stores/inquiries'
import { useSupportsStore } from '../../stores/supports'
import { useCommentsStore } from '../../stores/comments'
import { useSessionStore } from '../../stores/session'
import { useSharesStore } from '../../stores/shares'
import { useAttachmentsStore } from '../../stores/attachments'
import { BaseEntry, Event } from '../../Types/index.ts'
import { t } from '@nextcloud/l10n'
import moment from '@nextcloud/moment'
import {
  getInquiryTypeData,
} from '../../helpers/modules/InquiryHelper.ts'

import NcSelect from '@nextcloud/vue/components/NcSelect'
import NcButton from '@nextcloud/vue/components/NcButton'
import NcAvatar from '@nextcloud/vue/components/NcAvatar'
import NcBadge from '@nextcloud/vue/components/NcBadge'
import { InputDiv } from '../Base/index.ts'
import { ThumbIcon } from '../AppIcons'
import InquiryEditor from '../Editor/InquiryEditor.vue'
import { NcTextArea, NcRichText } from '@nextcloud/vue'
import { InquiryGeneralIcons, StatusIcons } from '../../utils/icons.ts'
import {
  canEdit,
  canSupport,
  canComment,
  createPermissionContextForContent,
  ContentType,
} from '../../utils/permissions.ts'

// Store declarations
const sessionStore = useSessionStore()
const commentsStore = useCommentsStore()
const supportsStore = useSupportsStore()
const inquiryStore = useInquiryStore()
const inquiriesStore = useInquiriesStore()
const sharesStore = useSharesStore()
const router = useRouter()
const attachmentsStore = useAttachmentsStore()
const imageFileInput = ref(null)

// Cover image references
const coverImageFileInput = ref(null)
const currentCoverUrl = ref('')

const triggerImageUpload = () => {
  imageFileInput.value?.click()
}

// Trigger cover image upload
const triggerCoverImageUpload = () => {
  coverImageFileInput.value?.click()
}

// Handle cover image upload
const handleCoverImageUpload = async (event) => {
  const file = event.target.files[0]
  if (!file) return
  
  try {
    const response = await attachmentsStore.upload(inquiryStore.id, file)
    
    // Update cover image in store
    await inquiryStore.setCoverImage(response.id)
    
    // Update displayed URL
    currentCoverUrl.value = getNextcloudPreviewUrl(response.id)
    
    showSuccess(t('agora', 'Cover image updated successfully'))
    
    // Reset input to allow selecting same file again
    event.target.value = ''
  } catch (error) {
    console.error('Failed to upload cover image:', error)
    showError(t('agora', 'Failed to upload cover image'))
  }
}

// Load current cover URL on mount
onMounted(() => {
  if (inquiryStore.coverId) {
    currentCoverUrl.value = getNextcloudPreviewUrl(inquiryStore.coverId)
  }
})

console.log('ðŸ”§ [InquiryEditViewForm] Component mounted - Debug info:')
console.log('ðŸ”§ Current user:', sessionStore.currentUser)
console.log('ðŸ”§ Inquiry store:', inquiryStore)

// Context for permissions
const context = computed(() => {
  const ctx = createPermissionContextForContent(
    ContentType.Inquiry,
    inquiryStore.owner.id,
    inquiryStore.configuration.access === 'public',
    inquiryStore.status.isLocked,
    inquiryStore.status.isExpired,
    inquiryStore.status.deletionDate > 0,
    inquiryStore.status.isArchived,
    inquiryStore.inquiryGroups.length > 0,
    inquiryStore.inquiryGroups,
    inquiryStore.type
  )
  console.log('ðŸ”§ [InquiryEditViewForm] Permission context:', ctx)
  return ctx
})

// Form fields
const selectedCategory = ref(inquiryStore.categoryId || 0)
const selectedLocation = ref(inquiryStore.locationId || 0)

const isLoaded = ref(false)

const hasSupported = computed(() => inquiryStore.currentUserStatus.hasSupported)

const isReadonly = computed(() => {
  const user = sessionStore.currentUser
  console.log('ðŸ”§ [InquiryEditViewForm] Checking readonly - User:', user)

  if (!user) {
    console.log('ðŸ”§ [InquiryEditViewForm] No user - READONLY')
    return true
  }

  const canEditResult = canEdit(context.value)
  console.log('ðŸ”§ [InquiryEditViewForm] canEdit result:', canEditResult)

  return !canEditResult
})

const isReadonlyDescription = computed(() => {
  console.log('ðŸ”§ [InquiryEditViewForm] isReadonlyDescription check - type:', inquiryStore.type, 'isReadonly:', isReadonly.value)

  if (inquiryStore.type === 'debate') {
    console.log('ðŸ”§ [InquiryEditViewForm] Debate type - EDITABLE')
    return false
  }
  console.log('ðŸ”§ [InquiryEditViewForm] Other type - READONLY:', isReadonly.value)
  return isReadonly.value
})

// Get current inquiry type data
const inquiryTypeData = computed(() => {
  const data = getInquiryTypeData(inquiryStore.type, sessionStore.appSettings.inquiryTypeTab || [])
  console.log('ðŸ”§ [InquiryEditViewForm] Inquiry type data:', data)
  return data
})

const availableInquiryStatuses = computed(() =>
  sessionStore.appSettings.inquiryStatusTab
    ?.filter((status) => status.inquiryType === inquiryStore.type)
    ?.sort((a, b) => a.order - b.order) || []
)

const currentInquiryStatus = computed(
  () => {
    const specialStatuses = {
      'draft': {
	statusKey: 'draft',
	label: 'Draft',
	icon: 'draft',
	inquiryType: inquiryStore.type,
	order: 0,
      },
      'waiting_approval': {
	statusKey: 'waiting_approval',
	label: 'Waiting Approval',
	icon: 'waitingapproval',
	inquiryType: inquiryStore.type,
	order: 1,
      }
    };

    const currentStatus = inquiryStore.status.inquiryStatus;

    if (specialStatuses[currentStatus]) {
      return specialStatuses[currentStatus];
    }

    return availableInquiryStatuses.value.find(
      (status) => status.statusKey === currentStatus
    ) || specialStatuses.draft; 
  }
)

const selectedInquiryStatusKey = ref(currentInquiryStatus.value?.statusKey)
const currentInquiryStatusLabel = computed(() => currentInquiryStatus.value?.label || 'Draft')
const currentInquiryStatusIcon = computed(() => {
const iconName = currentInquiryStatus.value?.icon?.toLowerCase() || 'draft'
return StatusIcons[iconName] || StatusIcons.Draft
})

const selectedInquiryStatus = computed({
  get: () => statusInquiryOptions.value.find(option => option.id === selectedInquiryStatusKey.value),
  set: (newValue) => {
    if (newValue) {
      selectedInquiryStatusKey.value = newValue.id
    }
  }
})

const onStatusChange = async (newStatus: string) => {
  try {
    const statusId = newStatus?.id || newStatus
    await inquiryStore.setInquiryStatus(statusId)
    showSuccess(t('agora', 'Inquiry status of this inquiry has been updated'))
  } catch (error) {
    console.error('Failed to update status:', error)
    selectedInquiryStatusKey.value = currentInquiryStatus.value.statusKey
  }
}

const isNoAccessSet = computed(
  () =>
    inquiryStore.configuration.access === 'private' &&
    !sharesStore.hasShares &&
    inquiryStore.permissions.edit
)

const subTexts = computed(() => {
  const subTexts = []

  if (inquiryStore.status.isArchived) {
    subTexts.push({
      id: 'deleted',
      text: t('agora', 'Archived'),
      class: 'archived',
      iconComponent: InquiryGeneralIcons.archived,
    })
    return subTexts
  }

  if (isNoAccessSet.value) {
    subTexts.push({
      id: 'no-access',
      text: [t('agora', 'Unpublished')].join('. '),
      class: 'unpublished',
      iconComponent: InquiryGeneralIcons.unpublished,
    })
    return subTexts
  }
  if (inquiryStore.configuration.access === 'private') {
    subTexts.push({
      id: inquiryStore.configuration.access,
      text: t('agora', 'A private inquiry from {name}', {
	name: inquiryStore.owner.displayName,
      }),
      class: '',
      iconComponent: InquiryGeneralIcons.private,
    })
  } else {
    subTexts.push({
      id: inquiryStore.configuration.access,
      text: t('agora', 'An openly accessible inquiry from {name}', {
	name: inquiryStore.owner.displayName,
      }),
      class: '',
      iconComponent: InquiryGeneralIcons.open,
    })
  }

  if (inquiryStore.isClosed) {
    subTexts.push({
      id: 'closed',
      text: timeExpirationRelative.value,
      class: 'closed',
      iconComponent: InquiryGeneralIcons.closed,
    })
    return subTexts
  }

  if (subTexts.length < 2) {
    subTexts.push({
      id: 'created',
      text: dateCreatedRelative.value,
      class: 'created',
      iconComponent: InquiryGeneralIcons.creation,
    })
  }
  return subTexts
})

const dateCreatedRelative = computed(() => moment.unix(inquiryStore.status.created).fromNow())

const timeExpirationRelative = computed(() => {
  if (inquiryStore.configuration.expire) {
    return moment.unix(inquiryStore.configuration.expire).fromNow()
  }
  return t('agora', 'never')
})

const statusInquiryOptions = computed(() => 
  availableInquiryStatuses.value.map(status => ({
    id: status.statusKey,
    label: t('agora', status.label),
  }))
)

// Get hierarchy path for location and category display
function getHierarchyPath(items, targetId) {
  const itemMap = {}

  items.forEach((item) => {
    itemMap[item.id] = item
  })

  if (!itemMap[targetId]) {
    return 'ID not found'
  }

  function buildPath(item) {
    if (item.parentId === 0) {
      return item.name
    }
    const parent = itemMap[item.parentId]
    if (parent) {
      return `${buildPath(parent)} -> ${item.name}`
    }
    return item.name
  }

  return buildPath(itemMap[targetId])
}

// Watchers for location and category
watch(
  selectedLocation,
  (newVal) => {
    const rawValue = toRaw(newVal)
    if (rawValue) {
      inquiryStore.locationId = rawValue.value
    }
  },
  { deep: true }
)

watch(
  selectedCategory,
  (newVal) => {
    const rawValue = toRaw(newVal)
    if (rawValue) {
      inquiryStore.categoryId = rawValue.value
    }
  },
  { deep: true }
)

// Build hierarchy for location and category dropdowns
function buildHierarchy(list: BaseEntry[], parentId = 0, depth = 0): BaseEntry[] {
  if (!Array.isArray(list)) return []
  return list
    .filter((item) => item?.parentId === parentId)
    .map((item) => {
      const children = buildHierarchy(list, item.id, depth + 1)
      return {
	...item,
	depth,
	children,
      }
    })
    .flatMap((item) => [item, ...item.children])
}

const hierarchicalLocation = computed(() => {
  if (!Array.isArray(sessionStore.appSettings.locationTab)) return []
  return buildHierarchy(sessionStore.appSettings.locationTab).map((item) => ({
    value: item.id,
    label: `${'â€” '.repeat(item.depth ?? 0)}${item.name ?? '[no name]'}`,
    original: item,
  }))
})

const hierarchicalCategory = computed(() => {
  if (!Array.isArray(sessionStore.appSettings.categoryTab)) return []
  return buildHierarchy(sessionStore.appSettings.categoryTab).map((item) => ({
    value: item.id,
    label: `${'â€” '.repeat(item.depth ?? 0)}${item.name ?? '[no name]'}`,
    original: item,
  }))
})

// Initialize location and category
watch(
  hierarchicalLocation,
  (locations) => {
    if (!locations.length) return
    if (inquiryStore.locationId === 0) {
      selectedLocation.value = locations[0]
      inquiryStore.locationId = locations[0].value
    } else {
      const selected = locations.find((loc) => loc.value === inquiryStore.locationId)
      selectedLocation.value = selected || locations[0]
      inquiryStore.locationId = selected?.value || locations[0].value
    }
  },
  { immediate: true }
)

watch(
  hierarchicalCategory,
  (categories) => {
    if (!categories.length) return
    if (inquiryStore.categoryId === 0) {
      selectedCategory.value = categories[0]
      inquiryStore.categoryId = categories[0].value
    } else {
      const selected = categories.find((loc) => loc.value === inquiryStore.categoryId)
      selectedCategory.value = selected || categories[0]
      inquiryStore.categoryId = selected?.value || categories[0].value
    }
  },
  { immediate: true }
)

// Toggle support
const onToggleSupport = async () => {
  const supported = supportsStore.toggleSupport(
    inquiryStore.id,
    sessionStore.currentUser.id,
    inquiryStore,
    inquiriesStore
  )
  if (inquiryStore.currentUserStatus.hasSupported) {
    showSuccess(t('agora', 'Thank you for your support!'), { timeout: 2000 })
  } else {
    showSuccess(t('agora', 'Support removed!'), { timeout: 2000 })
  }
  return supported
}

/**
 * Upload a single file and add to attachments list
 * @param file
 */
const handleImageUpload = async (event) => {
  const file = event.target.files[0]
  if (!file) return
  try {

    const response = await attachmentsStore.upload(inquiryStore.id, file)

    const attachment = {
      id: response.id ?? `temp-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      name: response.name ?? file.name,
      size: response.size ?? file.size,
      url: response.url ?? undefined,
    }

    // Use immutable update for better reactivity
    attachmentsStore.attachments = [...attachmentsStore.attachments, attachment]

    showSuccess(t('agora', '{file} uploaded', { file: response.name ?? file.name }))
  } catch (error) {
    console.error('Upload failed for file:', file.name, error)
    showError(t('agora', 'Failed to upload {file}', { file: file.name }))
    throw error // Re-throw to handle in parent function
    }

}

// Event subscriptions
onMounted(() => {
  subscribe(Event.UpdateComments, () => commentsStore.load())
  isLoaded.value = true
})

onUnmounted(() => {
  isLoaded.value = false
  unsubscribe(Event.UpdateComments, () => commentsStore.load())
})

// Determine if category/location should be shown as select or label
const showCategoryAsLabel = computed(() => {
  const result = inquiryStore.parentId !== 0 || isReadonly.value
  console.log('ðŸ”§ [InquiryEditViewForm] showCategoryAsLabel:', result, 'parentId:', inquiryStore.parentId, 'isReadonly:', isReadonly.value)
  return result
})

const showLocationAsLabel = computed(() => {
  const result = inquiryStore.parentId !== 0 || isReadonly.value
  console.log('ðŸ”§ [InquiryEditViewForm] showLocationAsLabel:', result, 'parentId:', inquiryStore.parentId, 'isReadonly:', isReadonly.value)
  return result
})

// Image URL function
function getNextcloudPreviewUrl(fileId, x = 1920, y = 1080, autoScale = true) {
  const baseUrl = window.location.origin
  return `${baseUrl}/index.php/core/preview?fileId=${fileId}&x=${x}&y=${y}&a=${autoScale}`
}

// Format date
const formatDate = (timestamp: number) => {
  return new Date(timestamp * 1000).toLocaleDateString()
}
</script>

<template>
	<div v-if="isLoaded" class="inquiry-edit-view">
		<!-- Cover image section IMPROVED -->
		<div class="cover-image-section">
			<input
				id="cover-image-upload-input"
				ref="coverImageFileInput"
				type="file"
				class="hidden"
				accept="image/*"
				:aria-label="t('agora', 'Select cover image')"
				@change="handleCoverImageUpload"
			/>
			
			<div v-if="currentCoverUrl" class="cover-image-container" @click="triggerCoverImageUpload">
				<img 
					:src="currentCoverUrl" 
					:alt="t('agora', 'Inquiry cover image')" 
					class="cover-image"
				/>
				<div class="cover-image-overlay">
					<NcButton type="primary" class="change-cover-btn">
						{{ t('agora', 'Change cover image') }}
					</NcButton>
				</div>
			</div>
			
			<div v-else class="cover-image-placeholder" @click="triggerCoverImageUpload">
				<NcButton type="primary" class="add-cover-btn">
					{{ t('agora', 'Add cover image') }}
				</NcButton>
			</div>
		</div>

		<!-- File upload section -->
		<div v-if="inquiryStore.currentUserStatus?.isOwner" class="attachment-upload">
			<input
					id="attachment-upload-input"
					ref="imageFileInput"
					:label="t('agora', 'Select files to upload')"
					type="file"
					class="hidden"
					accept="image/*"
					:aria-label="t('agora', 'Select files to upload')"
					@change="handleImageUpload"
					/>
			<NcButton
					type="primary"
					:aria-label="t('agora', 'Add files')"
					@click="triggerImageUpload"
					>
					{{ t('agora', 'Cover files') }}
			</NcButton>
		</div>

		<!-- User info section FIXED -->
		<div class="user-info-section">
			<div class="header-left-content">
				<NcAvatar
					v-if="inquiryStore.ownedGroup !== null"
					:display-name="inquiryStore.ownedGroup"
					:show-user-status="false"
					:size="44"
				/>
				<NcAvatar
					v-else
					:user="inquiryStore.owner.id"
					:display-name="inquiryStore.owner.displayName"
					:size="44"
				/>
				<div class="user-details">
					<span class="user-name">
						{{ inquiryStore.ownedGroup !== null ? inquiryStore.ownedGroup : inquiryStore.owner.displayName }}
					</span>
				</div>
			</div>
		</div>

		<!-- Main content section -->
		<div class="main-content-section">
			<!-- Title row with counters -->
			<div class="title-row">
				<div class="title-content">
					<h1 class="inquiry-title">{{ inquiryStore.title }}</h1>
				</div>
				<div class="counters">
					<div v-if="canComment(context)" class="counter-item">
						<component :is="InquiryGeneralIcons.comment" :size="20" />
						<span>{{ commentsStore.comments.length || 0 }}</span>
					</div>
					<div v-if="canSupport(context)" class="counter-item" @click="onToggleSupport">
						<ThumbIcon :supported="hasSupported" />
						<span>{{ inquiryStore.status.countSupports || 0 }}</span>
					</div>
				</div>
			</div>

			<!-- Metadata section FIXED -->
			<div class="metadata-section">
				<div class="metadata-grid">
					<div class="metadata-item">
						<component :is="inquiryTypeData.icon" :size="16" />
						<span class="metadata-label">{{ t('agora', 'Type') }}:</span>
						<span class="metadata-value">{{ inquiryTypeData.label }}</span>
					</div>

					<div class="metadata-item">
						<component :is="InquiryGeneralIcons.location" :size="16" />
						<span class="metadata-label">{{ t('agora', 'Location') }}:</span>
						<NcSelect
								v-if="!showLocationAsLabel"
								v-model="selectedLocation"
								:options="hierarchicalLocation"
								:clearable="false"
								:label-outside="true"
								class="select-field location-select"
								required
								/>
						<span v-else class="metadata-value">
							{{ getHierarchyPath(sessionStore.appSettings.locationTab, inquiryStore.locationId) || t('agora', 'Inherited from parent') }}
						</span>
					</div>

					<div class="metadata-item">
						<component :is="StatusIcons.Calendar" :size="16" />
						<span class="metadata-label">{{ t('agora', 'Created') }}:</span>
						<span class="metadata-value">{{ formatDate(inquiryStore.status.created) }}</span>
					</div>

					<div class="metadata-item">
						<component :is="InquiryGeneralIcons.tag" :size="16" />
						<span class="metadata-label">{{ t('agora', 'Category') }}:</span>
						<NcSelect
								v-if="!showCategoryAsLabel"
								v-model="selectedCategory"
								:options="hierarchicalCategory"
								:clearable="false"
								:label-outside="true"
								class="select-field category-select"
								required
								/>
						<span v-else class="metadata-value">
							{{ getHierarchyPath(sessionStore.appSettings.categoryTab, inquiryStore.categoryId) || t('agora', 'Inherited from parent') }}
						</span>
					</div>

					<div class="metadata-item last-interaction-item">
						<component :is="StatusIcons.Updated" :size="16" />
						<span class="metadata-label">{{ t('agora', 'Last interaction') }}:</span>
						<span class="metadata-value">{{ formatDate(inquiryStore.status.lastInteraction) }}</span>
					</div>

					<div class="metadata-item status-item">
						<component :is="currentInquiryStatusIcon" :size="16" />
						<span class="metadata-label">{{ t('agora', 'Status') }}:</span>
						<template v-if="sessionStore.currentUser.isModerator">
							<NcSelect
									v-model="selectedInquiryStatus"
									:options="statusInquiryOptions"
									:clearable="false"
									@update:model-value="onStatusChange"
									class="status-select"
									/>
						</template>
						<template v-else>
							<span class="metadata-value">{{ t('agora', currentInquiryStatusLabel) }}</span>
						</template>
					</div>

					<div v-if="inquiryStore.configuration.expire" class="metadata-item">
						<component :is="InquiryGeneralIcons.expiration" :size="16" />
						<span class="metadata-label">{{ t('agora', 'Expires') }}:</span>
						<span class="metadata-value">{{ timeExpirationRelative }}</span>
					</div>
				</div>
			</div>

			<!-- Description section FIXED -->
			<div class="description-section">
				<h3 class="section-title">{{ t('agora', 'Description') }}</h3>
				<div class="description-content">
					<div
							v-if="sessionStore.appSettings.inquiryTypeRights[inquiryStore.type].editorType === 'wysiwyg'"
							class="editor-container"
							>
							<InquiryEditor v-model="inquiryStore.description" :readonly="isReadonlyDescription" />
					</div>

						<div
								v-else-if="sessionStore.appSettings.inquiryTypeRights[inquiryStore.type].editorType === 'texteditor'"
								class="editor-container rich-text-container"
								>
								<NcRichText
										v-model="inquiryStore.description"
										:autolink="true"
										:use-markdown="true"
										:disabled="isReadonlyDescription"
										class="rich-text-editor"
										/>
						</div>

							<div v-else class="editor-container">
								<NcTextArea
										v-model="inquiryStore.description"
										:disabled="isReadonlyDescription"
										class="text-area-editor"
										:rows="8"
										/>
							</div>
				</div>
			</div>
		</div>
	</div>
</template>

<style scoped lang="scss">
.inquiry-edit-view {
	padding: 10px;
	background: var(--color-main-background);
	border-radius: var(--border-radius-large);
}

/* Cover image section IMPROVED */
.cover-image-section {
	width: 100%;
	margin-bottom: 1rem;
	border-radius: var(--border-radius-large);
	overflow: hidden;
	position: relative;
	cursor: pointer;
	
	&:hover {
		.cover-image-overlay {
			opacity: 1;
		}
	}
}

.cover-image-container {
	position: relative;
	width: 100%;
	height: 300px;
}

.cover-image {
	width: 100%;
	height: 100%;
	object-fit: cover;
}

.cover-image-overlay {
	position: absolute;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	background: rgba(0, 0, 0, 0.5);
	display: flex;
	align-items: center;
	justify-content: center;
	opacity: 0;
	transition: opacity 0.3s ease;
}

.cover-image-placeholder {
	width: 100%;
	height: 200px;
	background: var(--color-background-dark);
	border: 2px dashed var(--color-border);
	border-radius: var(--border-radius-large);
	display: flex;
	align-items: center;
	justify-content: center;
	
	&:hover {
		border-color: var(--color-primary);
		background: var(--color-background-hover);
	}
}

.change-cover-btn,
.add-cover-btn {
	z-index: 2;
}

/* File upload section */
.attachment-upload {
	margin-bottom: 1rem;
	padding: 1rem;
	background: var(--color-background-dark);
	border-radius: var(--border-radius-large);
	z-index: 10;
	position: relative;
}

.hidden {
	display: none;
}

/* User info section FIXED */
.user-info-section {
	display: flex;
	align-items: center;
	gap: 0.75rem;
	margin-bottom: 1rem;
	padding: 1rem;
	background: var(--color-background-dark);
	border-radius: var(--border-radius);
}

.header-left-content {
	display: flex;
	align-items: center;
	gap: 16px;
}

.user-details {
	display: flex;
	flex-direction: column;
}

.user-name {
	font-weight: 600;
	color: var(--color-primary);
}

/* Main content section */
.main-content-section {
	background: var(--color-background-dark);
	border-radius: var(--border-radius-large);
	padding: 1.5rem;
	margin-bottom: 1rem;
}

/* Title row */
.title-row {
	display: flex;
	justify-content: space-between;
	align-items: flex-start;
	margin-bottom: 1.5rem;
	gap: 1rem;
}

.title-content {
	flex: 1;
}

.inquiry-title {
	font-size: 1.5rem;
	font-weight: 700;
	color: var(--color-primary-text);
	margin: 0;
	line-height: 1.3;
}

.counters {
	display: flex;
	gap: 1.5rem;
	align-items: center;
}

  .counter-item {
	  display: flex;
	  align-items: center;
	  gap: 0.5rem;
	  cursor: pointer;
	  padding: 0.5rem;
	  border-radius: var(--border-radius);
	  transition: background-color 0.2s;

	  &:hover {
		  background: var(--color-background-hover);
	  }

	  span {
		  font-weight: bold;
		  color: var(--color-primary-text);
	  }
  }

  /* Metadata section FIXED */
  .metadata-section {
	  margin-bottom: 1.5rem;
	  padding: 1rem;
	  background: var(--color-background-darker);
	  border-radius: var(--border-radius);
  }

  .metadata-grid {
	  display: grid;
	  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
	  gap: 1rem;
  }

  /* Specific alignment for items */
  .metadata-item {
	  display: flex;
	  align-items: center;
	  gap: 0.5rem;
	  font-size: 0.9rem;
	  
	  &.status-item,
	  &.last-interaction-item {
		  justify-self: start;
	  }
  }

  .metadata-label {
	  font-weight: 600;
	  color: var(--color-text-lighter);
	  white-space: nowrap;
	  min-width: fit-content;
  }

  .metadata-value {
	  color: var(--color-primary-text);
	  white-space: nowrap;
  }

  .select-field {
	  width: 100%;

	  &.location-select,
	  &.category-select {
		  max-width: 250px;
	  }
  }

  .status-select {
	  min-width: 120px;
  }

  /* Description section FIXED */
  .description-section {
	  margin-bottom: 1rem;
  }

  .section-title {
	  color: var(--color-primary);
	  font-size: 1.1rem;
	  font-weight: 600;
	  margin-bottom: 1rem;
  }

  .description-content {
	  border: 1px solid var(--color-border);
	  border-radius: var(--border-radius);
	  background: var(--color-main-background);
	  overflow: hidden;
  }

  .editor-container {
	  width: 100%;
	  
	  &.rich-text-container {
		  min-height: 200px;
	  }
  }

  .rich-text-editor,
  .text-area-editor {
	  width: 100%;
	  border: none;
	  min-height: 200px;
  }

  .rich-text-editor {
	  :deep(.ProseMirror) {
		  min-height: 200px;
		  padding: 12px;
	  }
  }

  .text-area-editor {
	  resize: vertical;
	  padding: 12px;
  }

  /* Improved mobile responsive */
  @media (max-width: 768px) {
	  .title-row {
		  flex-direction: column;
		  align-items: flex-start;
	  }

	  .counters {
		  width: 100%;
		  justify-content: space-around;
	  }

	  .metadata-grid {
		  grid-template-columns: 1fr;
		  gap: 0.75rem;
	  }

	  .metadata-item {
		  flex-wrap: wrap;
		  gap: 0.25rem;
	  }

	  .select-field.location-select,
	  .select-field.category-select {
		  max-width: 100%;
	  }
	  
	  .cover-image-container {
		  height: 200px;
	  }
	  
	  .cover-image-placeholder {
		  height: 150px;
	  }
	  
	  .rich-text-editor,
	  .text-area-editor {
		  min-height: 150px;
	  }
  }

  @media (max-width: 480px) {
	  .header-left-content {
		  flex-direction: column;
		  text-align: center;
		  gap: 8px;
	  }
	  
	  .user-details {
		  align-items: center;
	  }
  }
</style>
